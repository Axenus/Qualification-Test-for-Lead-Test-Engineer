import socket  # Импортируем модуль socket для работы с сетевыми соединениями
import psycopg2  # Импортируем модуль psycopg2 для взаимодействия с PostgreSQL
import struct  # Импортируем модуль struct для работы с упакованными данными
import uuid  # Импортируем модуль uuid для работы с UUID

# Параметры подключения к базе данных
DB_CONFIG = {
    'user': 'postgres',  # Имя пользователя базы данных
    'password': '123123',  # Пароль пользователя базы данных
    'database': 'postgres',  # Имя базы данных
    'host': 'localhost',  # Хост базы данных
    'port': 5432  # Порт базы данных
}

# Создаем TCP-серверный сокет
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Создаем сокет с IPv4 и протоколом TCP
server_socket.bind(
    ('0.0.0.0', 12346))  # Привязываем сокет к адресу и порту; '0.0.0.0' означает все доступные интерфейсы
server_socket.listen(5)  # Начинаем прослушивание входящих соединений; максимальная очередь — 5
print("Сервер ожидает подключения...")  # Выводим сообщение о готовности сервера

while True:
    client_socket, address = server_socket.accept()  # Принимаем новое входящее соединение
    print(f"Подключен клиент: {address}")  # Выводим адрес подключенного клиента

    try:
        # Получаем данные от клиента
        data = client_socket.recv(1024)  # Читаем до 1024 байт данных из сокета
        if not data:
            continue  # Если данных нет, продолжаем ожидание

        # Распаковываем первый байт для определения кода операции
        code = struct.unpack('!B', data[:1])[0]  # '!B' означает большой порядок байтов и один беззнаковый байт
        if code == 34:  # Проверяем, соответствует ли код запросу "Получить список активных пользователей"
            # Подключаемся к базе данных
            with psycopg2.connect(**DB_CONFIG) as conn:  # Открываем соединение с базой данных
                with conn.cursor() as cursor:  # Создаем курсор для выполнения SQL-запросов
                    # Выполняем SQL-запрос для получения активных пользователей
                    cursor.execute("SELECT id FROM sh_admin.tbl_user_c WHERE active = true")
                    active_users = cursor.fetchall()  # Извлекаем все результаты запроса

                    # Формируем ответную кодограмму
                    response_code = 65  # Устанавливаем код ответа (например, 65)
                    user_count = len(active_users)  # Определяем количество активных пользователей

                    # Упаковываем код ответа и количество пользователей в байтовую строку
                    response = struct.pack('!B I', response_code, user_count)

                    # Обрабатываем каждого пользователя из списка активных пользователей
                    for user in active_users:
                        try:
                            # Преобразуем идентификатор пользователя в объект UUID
                            user_uuid = uuid.UUID(user[0])
                            response += user_uuid.bytes  # Добавляем байтовое представление UUID к ответу
                        except Exception as e:
                            # Если возникает ошибка при обработке UUID, выводим сообщение об ошибке
                            print(f"Ошибка при обработке UUID пользователя: {user[0]}, ошибка: {e}")

                    # Выводим размер сформированного ответа для логирования
                    print(f"Размер ответа: {len(response)} байт")
                    client_socket.sendall(response)  # Отправляем весь сформированный ответ клиенту

    except Exception as e:
        # Если возникает ошибка при обработке клиента, выводим сообщение об ошибке
        print(f"Ошибка при обработке клиента {address}: {e}")
    finally:
        client_socket.close()  # Закрываем соединение с клиентом
