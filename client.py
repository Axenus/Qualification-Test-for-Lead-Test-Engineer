import socket  # Импортируем модуль socket для работы с сетевыми соединениями
import struct  # Импортируем модуль struct для упаковки и распаковки бинарных данных
import uuid  # Импортируем модуль uuid для работы с UUID

# Параметры подключения к серверу
SERVER_ADDRESS = '127.0.0.1'  # IP-адрес сервера
SERVER_PORT = 12346  # Порт сервера

# Создаем TCP клиентский сокет и подключаемся к серверу
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Создаем сокет с IPv4 и TCP протоколом
client_socket.connect((SERVER_ADDRESS, SERVER_PORT))  # Подключаемся к серверу по указанному адресу и порту

try:
    # Формируем кодограмму с кодом запроса 34
    request_code = 34  # Код запроса для получения списка активных пользователей
    request = struct.pack('!B',
                          request_code)  # Упаковываем код запроса в байтовый формат ('!B' - big-endian, unsigned char)

    # Отправляем запрос на сервер
    client_socket.sendall(request)  # Отправляем сформированный запрос на сервер
    print("Запрос отправлен на сервер.")  # Выводим сообщение об отправке запроса

    # Получаем ответ от сервера
    # Сначала читаем первые 5 байт: код ответа (1 байт) и количество пользователей (4 байта)
    header = client_socket.recv(5)  # Читаем первые 5 байт ответа
    if len(header) < 5:
        print("Получен неполный заголовок от сервера.")  # Если заголовок меньше 5 байт, выводим сообщение об ошибке
    else:
        # Распаковываем код ответа и количество пользователей
        response_code, user_count = struct.unpack('!B I', header)  # '!B I' - big-endian, unsigned char и unsigned int
        print(
            f"Код ответа: {response_code}, Количество пользователей: {user_count}")  # Выводим код ответа и количество пользователей

        # Проверяем корректность кода ответа
        if response_code != 65:  # 65 - ожидаемый код успешного ответа
            print(
                "Получен некорректный код ответа от сервера.")  # Если код ответа неверный, выводим сообщение об ошибке
        else:
            # Получаем список UUID пользователей
            user_uuids = []  # Инициализируем список для хранения UUID пользователей
            total_bytes = user_count * 16  # Вычисляем общее количество байт для всех UUID (каждый UUID занимает 16 байт)
            data = b''  # Инициализируем переменную для хранения полученных данных

            # Читаем данные до тех пор, пока не получим все байты UUID
            while len(data) < total_bytes:
                packet = client_socket.recv(total_bytes - len(data))  # Читаем оставшееся количество байт
                if not packet:
                    break  # Если данных больше нет, выходим из цикла
                data += packet  # Добавляем полученные данные к общей переменной

            if len(data) < total_bytes:
                print(
                    "Получены не все данные от сервера.")  # Если получено меньше байт, чем ожидалось, выводим сообщение об ошибке
            else:
                # Разбираем полученные байты на отдельные UUID
                for i in range(user_count):
                    uuid_bytes = data[i * 16:(i + 1) * 16]  # Извлекаем байты для каждого UUID
                    user_uuid = uuid.UUID(bytes=uuid_bytes)  # Создаем объект UUID из байтов
                    user_uuids.append(user_uuid)  # Добавляем UUID в список

                # Выводим полученные UUID пользователей
                print("Список активных пользователей:")
                for user_uuid in user_uuids:
                    print(user_uuid)  # Выводим каждый UUID

except Exception as e:
    # Обрабатываем исключения и выводим сообщение об ошибке
    print(f"Ошибка при работе с сервером: {e}")
finally:
    client_socket.close()  # Закрываем сокет независимо от того, возникло ли исключение или нет
